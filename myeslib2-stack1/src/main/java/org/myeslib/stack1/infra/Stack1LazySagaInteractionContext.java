package org.myeslib.stack1.infra;

import org.myeslib.core.EventSourced;
import org.myeslib.data.Command;
import org.myeslib.data.CommandId;
import org.myeslib.data.Event;
import org.myeslib.infra.CommandScheduler;
import org.myeslib.infra.Consumers;
import org.myeslib.infra.SagaInteractionContext;
import org.myeslib.stack1.infra.helpers.MultiMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static com.google.common.base.Preconditions.checkNotNull;

public class Stack1LazySagaInteractionContext<E extends EventSourced> implements SagaInteractionContext {

    private static final Logger log = LoggerFactory.getLogger(Stack1LazySagaInteractionContext.class);
    private CommandId commandId;
    private final EventSourced eventSourced;
    private final CommandScheduler commandScheduler;
    private final Consumers<E> consumers;
    private final MultiMethod mm ;
    private final List<Event> emmitedEvents;
    private final List<Command> emittedCommands;
    private final List<CommandSchedule> commandSchedules;
    private final List<RunnableSideEffect> emmitedSideEffects;

    public Stack1LazySagaInteractionContext(EventSourced eventSourced, CommandScheduler commandScheduler, Consumers<E> consumers) {
        checkNotNull(eventSourced);
        this.eventSourced = eventSourced;
        checkNotNull(commandScheduler);
        this.commandScheduler = commandScheduler;
        checkNotNull(consumers);
        this.consumers = consumers;
        mm = MultiMethod.getMultiMethod(eventSourced.getClass(), "on");
        emmitedEvents = new ArrayList<>();
        commandSchedules = new ArrayList<>();
        emittedCommands = new ArrayList<>();
        emmitedSideEffects = new ArrayList<>();
    }

    @Override
    public void emit(Event event) {
        checkNotNull(event);
        log.debug("applying event {} generated by an operation on {}", event, eventSourced);
        _applyEventsOn(eventSourced, event);
        log.debug("status after event applied {}", eventSourced);
        emmitedEvents.add(event);
    }

    @Override
    public List<Event> getEmittedEvents() {
        return Collections.unmodifiableList(emmitedEvents);
    }

    private void _applyEventsOn(EventSourced instance, Event event) {
        try {
            mm.invoke(instance, event);
        } catch (Exception e) {
            throw new RuntimeException("Error when applying events via reflection", e.getCause());
        }
    }

    @Override
    public CommandId getCommandId() {
        return commandId;
    }

    @Override
    public void setCommandId(CommandId commandId) {
        this.commandId = commandId;
    }

    @Override
    public void emitCommand(Command command) {
        emittedCommands.add(command);
    }

    @Override
    public void scheduleCommand(CommandSchedule command) {
        commandSchedules.add(command);
    }

    @Override
    public void emitSideEffect(RunnableSideEffect runnableSideEffect) {
        emmitedSideEffects.add(runnableSideEffect);
    }

    @Override
    public void processSideEffects() {

        for (RunnableSideEffect runnableSideEffect : emmitedSideEffects) {
            log.debug("Processing side effect {} for commandId = {}", runnableSideEffect.getDescription(), getCommandId());
            runnableSideEffect.run();
        }

        if (!emittedCommands.isEmpty()) {
            log.debug("Calling back consumers of emitted commands for commandId = {}", getCommandId());
            consumers.consumeCommands(emittedCommands);
        }

        for (CommandSchedule commandSchedule : commandSchedules) {
            log.debug("Scheduling command for commandId = {}", getCommandId());
            if (commandSchedule.getInstant().isPresent()) {
                commandScheduler.schedule(commandSchedule.getCommand(), commandSchedule.getInstant().get());
            } else {
                commandScheduler.schedule(commandSchedule.getCommand());
            }
        }

    }

}
