package org.myeslib.stack1.infra;

import org.myeslib.core.EventSourced;
import org.myeslib.data.Command;
import org.myeslib.data.CommandId;
import org.myeslib.data.Event;
import org.myeslib.infra.CommandScheduler;
import org.myeslib.infra.Consumers;
import org.myeslib.infra.SagaInteractionContext;
import org.myeslib.stack1.infra.helpers.MultiMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static com.google.common.base.Preconditions.checkNotNull;

public class Stack1SagaInteractionContext<E extends EventSourced> implements SagaInteractionContext {

    private static final Logger log = LoggerFactory.getLogger(Stack1SagaInteractionContext.class);
    private CommandId commandId;
    private final EventSourced eventSourced;
    private final CommandScheduler commandScheduler;
    private final Consumers<E> consumers;
    private final MultiMethod mm ;
    private final List<Event> emittedEvents;
    private final List<Command> emittedCommands;
    private final List<CommandSchedule> commandSchedules;
    private final List<RunnableSideEffect> emittedSideEffects;

    public Stack1SagaInteractionContext(EventSourced eventSourced, CommandScheduler commandScheduler, Consumers<E> consumers) {
        checkNotNull(eventSourced);
        this.eventSourced = eventSourced;
        checkNotNull(commandScheduler);
        this.commandScheduler = commandScheduler;
        checkNotNull(consumers);
        this.consumers = consumers;
        mm = MultiMethod.getMultiMethod(eventSourced.getClass(), "on");
        emittedEvents = new ArrayList<>();
        emittedCommands = new ArrayList<>();
        commandSchedules = new ArrayList<>();
        emittedSideEffects = new ArrayList<>();
    }

    @Override
    public void emit(Event event) {
        checkNotNull(event);
        log.debug("applying event {} generated by an operation on {}", event, eventSourced);
        _applyEventsOn(eventSourced, event);
        log.debug("status after event applied {}", eventSourced);
        emittedEvents.add(event);
    }

    @Override
    public List<Event> getEmittedEvents() {
        return Collections.unmodifiableList(emittedEvents);
    }

    private void _applyEventsOn(EventSourced instance, Event event) {
        try {
            mm.invoke(instance, event);
        } catch (Exception e) {
            throw new RuntimeException("Error when applying events via reflection", e.getCause());
        }
    }

    @Override
    public CommandId getCommandId() {
        return commandId;
    }

    @Override
    public void setCommandId(CommandId commandId) {
        checkNotNull(commandId);
        this.commandId = commandId;
    }

    @Override
    public void emitCommand(Command command) {
        checkNotNull(command);
        emittedCommands.add(command);
    }

    @Override
    public void scheduleCommand(CommandSchedule command) {
        commandSchedules.add(command);
        commandScheduler.schedule(command.getCommand());
    }

    @Override
    public void emitSideEffect(RunnableSideEffect runnableSideEffect) {
        emittedSideEffects.add(runnableSideEffect);
        log.debug("Processing side effect {} for commandId = {}", runnableSideEffect.getDescription(), getCommandId());
        runnableSideEffect.run();
    }

    @Override
    public void processSideEffects() {
        if (!emittedCommands.isEmpty()) {
            consumers.consumeCommands(emittedCommands);
        }
    }

}
